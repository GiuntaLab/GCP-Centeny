suppressPackageStartupMessages({
  library(argparse)
  library(parallel)
  library(dplyr)
  library(data.table)
})

# Calculate bp distance between two consecutive DNA motif
dist_f <- function(data) {
  data  %>%
    group_by(V1) %>%
    mutate(distance = abs(V2 - lag(V3))) %>% # Create new column for bp-distance values
    ungroup() %>%
    na.omit()
}

# Search for a match between the k-patterns of a chromosome and the distance values within the reads
is_substring <- function(a, b) { 
  a_str <- paste(a, collapse = ",") # Convert vectors to strings 
  b_str <- paste(b, collapse = ",")  
  grepl(a_str, b_str, fixed = TRUE) # Use grepl to check if `a_str` (chromosome pattern) is in `b_str` (reads bp-distance values)
}

parser <- ArgumentParser(description = "Reads_retrieval isolates chromosome-specific centromeric reads from a FASTA/FASTQ file by using chromosome-specific kpatterns from model3")
parser$add_argument("-i", "--input", help = "DNA motif annotation file, generated by applying the fuzznuc module to long sequencing reads", type = "character", required = TRUE, metavar = "FILE")
parser$add_argument("-p", "--pattern_table", help = "Input table from model3 which stores all the k-patterns with a sliding step of 1", type = "character", required = TRUE, metavar = "FILE")
parser$add_argument("-c", "--chr", help = "Chromosome of interest (names are stored in column 3 of the file in pattern_table)", type = "character", required = TRUE, metavar = "CHR_NAME")
parser$add_argument("--n_box", help = "Filter out reads with number of motif occurrences lower than INT (this parameter must to be equal to/higher than the number of distances in the k-pattern)", type = "integer", required = TRUE, metavar = "INT")
parser$add_argument("--n_pattern", help = "Consider only k-patterns with frequency higher than INT within the selected chromosome [default 10]", type = "integer", default = 10, metavar = "INT")
parser$add_argument("--n_matches", help = "Assign the read to the selected chromosome if it contains at least INT considered k-patterns [default 1]", type = "integer", default = 1, metavar = "INT")
parser$add_argument("-t", "--n_cores", help = "Number of threads [default 5]", type = "integer", default = 5, metavar = "INT")
parser$add_argument("-o", "--output_file", help = "Name of the output file [default chr_specific_reads.txt]", type = "character", default = "chr_specific_reads.txt", metavar = "FILE")
args <- parser$parse_args()

# Check if all the required inputs are parsed
if (is.null(args$input) || is.null(args$pattern_table) || is.null(args$chr) || is.null(args$n_box)) {
  cat("Required inputs with the DNA motif annotation\n")
  quit(status = 1) # Exit the script with an error status
} else {
  cat("Reading input file...\n")
  df_r <- fread(args$input)
  df_g <- read.delim(args$pattern_table, header = F)
  k <- (args$n_box)
  t <- (args$n_cores)
  fq <- (args$n_pattern)
  n <- (args$n_matches)
  chr_specific <- (args$chr)
  output_file <- (args$output_file)
}

cat(sprintf("Filtering out reads having n. of boxes less than k%d\n", k))
df_r <- df_r %>%
  group_by(V1) %>%
  filter(n() > k) %>% #n_box (k) must to be equal or higher than k used in model3
  arrange(V1, V2) %>%
  as.data.table()

cat(sprintf("Filtering chr-specific k-pattern by frequency higher than %d\n", fq))
df_g <- df_g %>%
  filter(V2 > fq) %>% # Filter rows where the frequency in V2 is greater than fq
  filter(V3 == chr_specific) %>% # Isolate k-patterns of the chromosome of interest
  arrange(V1, V2) %>% # Arrange by V1 and V2
  as.data.table()

# Creating list of dataframe by chromosome
df_r <- split(df_r, df_r$V1)

cat("Calculating bp-distances within the reads...\n")
data_fd <- mclapply(df_r, dist_f, mc.cores = t) # bp-distance
#data_fd <- lapply(data_fd, na.omit) #to remove all the NA distance values (NA values belong to the first CENP-B box of the chromosome)
data_fd <- bind_rows(data_fd)

#patterns <- df_g$V1
# Extract numeric vector
patterns <- lapply(df_g$V1, function(pattern) {
  strsplit(gsub("[c\\(\\)]", "", pattern), ", ")[[1]] %>% as.numeric()
})
# Name patterns
names(patterns) <- paste0("chr", seq_along(patterns))

# Create a list of each read and its sequence of numbers
split_distances <- split(data_fd$distance, data_fd$V1)

cat("Finding the matches...\n")

# Find the matches between sequence of numbers
matches <- mclapply(split_distances, function(distances) {
  sapply(patterns, function(pattern) {
    is_substring(pattern, distances)
  })
}, mc.cores = t) # `t` is the number of cores to use

# Ensure matches is a named list
names(matches) <- names(split_distances)

# Extract results: Chromosomes with at least one match
#results <- names(matches)[sapply(matches, function(x) any(x))] #at least 1 kpattern matches the string of numbers in the read
results <- names(matches)[sapply(matches, function(x) sum(x) >= n)] #at least 1 kpattern matches the string of numbers in the read

cat("Matches found:\n")
print(length(results))

# output_file <- file.path(dirname(args$pattern_table), "chr_specific_reads.txt")
# write.table(results, output_file, sep="\t", col.names = F, row.names = F, quote = F)
write.table(results, output_file, sep = "\t", col.names = F, row.names = F, quote = F)